// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.20.3
// source: TaskInfo.proto

package taskinfo

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	InferWorkerService_ReceiveTasksFromScheduler_FullMethodName = "/InferWorkerService/ReceiveTasksFromScheduler"
	InferWorkerService_SendKVCacheData_FullMethodName           = "/InferWorkerService/SendKVCacheData"
	InferWorkerService_RecvKVCacheData_FullMethodName           = "/InferWorkerService/RecvKVCacheData"
	InferWorkerService_ShutDown_FullMethodName                  = "/InferWorkerService/ShutDown"
)

// InferWorkerServiceClient is the client API for InferWorkerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// InferWorker 服务
type InferWorkerServiceClient interface {
	ReceiveTasksFromScheduler(ctx context.Context, in *TaskInfoList, opts ...grpc.CallOption) (*Empty, error)
	SendKVCacheData(ctx context.Context, in *CombindedTaskInfo, opts ...grpc.CallOption) (*Empty, error)
	RecvKVCacheData(ctx context.Context, in *CombindedTaskInfo, opts ...grpc.CallOption) (*Empty, error)
	ShutDown(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
}

type inferWorkerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewInferWorkerServiceClient(cc grpc.ClientConnInterface) InferWorkerServiceClient {
	return &inferWorkerServiceClient{cc}
}

func (c *inferWorkerServiceClient) ReceiveTasksFromScheduler(ctx context.Context, in *TaskInfoList, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, InferWorkerService_ReceiveTasksFromScheduler_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inferWorkerServiceClient) SendKVCacheData(ctx context.Context, in *CombindedTaskInfo, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, InferWorkerService_SendKVCacheData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inferWorkerServiceClient) RecvKVCacheData(ctx context.Context, in *CombindedTaskInfo, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, InferWorkerService_RecvKVCacheData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inferWorkerServiceClient) ShutDown(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, InferWorkerService_ShutDown_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InferWorkerServiceServer is the server API for InferWorkerService service.
// All implementations must embed UnimplementedInferWorkerServiceServer
// for forward compatibility.
//
// InferWorker 服务
type InferWorkerServiceServer interface {
	ReceiveTasksFromScheduler(context.Context, *TaskInfoList) (*Empty, error)
	SendKVCacheData(context.Context, *CombindedTaskInfo) (*Empty, error)
	RecvKVCacheData(context.Context, *CombindedTaskInfo) (*Empty, error)
	ShutDown(context.Context, *Empty) (*Empty, error)
	mustEmbedUnimplementedInferWorkerServiceServer()
}

// UnimplementedInferWorkerServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedInferWorkerServiceServer struct{}

func (UnimplementedInferWorkerServiceServer) ReceiveTasksFromScheduler(context.Context, *TaskInfoList) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReceiveTasksFromScheduler not implemented")
}
func (UnimplementedInferWorkerServiceServer) SendKVCacheData(context.Context, *CombindedTaskInfo) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendKVCacheData not implemented")
}
func (UnimplementedInferWorkerServiceServer) RecvKVCacheData(context.Context, *CombindedTaskInfo) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecvKVCacheData not implemented")
}
func (UnimplementedInferWorkerServiceServer) ShutDown(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShutDown not implemented")
}
func (UnimplementedInferWorkerServiceServer) mustEmbedUnimplementedInferWorkerServiceServer() {}
func (UnimplementedInferWorkerServiceServer) testEmbeddedByValue()                            {}

// UnsafeInferWorkerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InferWorkerServiceServer will
// result in compilation errors.
type UnsafeInferWorkerServiceServer interface {
	mustEmbedUnimplementedInferWorkerServiceServer()
}

func RegisterInferWorkerServiceServer(s grpc.ServiceRegistrar, srv InferWorkerServiceServer) {
	// If the following call pancis, it indicates UnimplementedInferWorkerServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&InferWorkerService_ServiceDesc, srv)
}

func _InferWorkerService_ReceiveTasksFromScheduler_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskInfoList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InferWorkerServiceServer).ReceiveTasksFromScheduler(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InferWorkerService_ReceiveTasksFromScheduler_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InferWorkerServiceServer).ReceiveTasksFromScheduler(ctx, req.(*TaskInfoList))
	}
	return interceptor(ctx, in, info, handler)
}

func _InferWorkerService_SendKVCacheData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CombindedTaskInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InferWorkerServiceServer).SendKVCacheData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InferWorkerService_SendKVCacheData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InferWorkerServiceServer).SendKVCacheData(ctx, req.(*CombindedTaskInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _InferWorkerService_RecvKVCacheData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CombindedTaskInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InferWorkerServiceServer).RecvKVCacheData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InferWorkerService_RecvKVCacheData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InferWorkerServiceServer).RecvKVCacheData(ctx, req.(*CombindedTaskInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _InferWorkerService_ShutDown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InferWorkerServiceServer).ShutDown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InferWorkerService_ShutDown_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InferWorkerServiceServer).ShutDown(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// InferWorkerService_ServiceDesc is the grpc.ServiceDesc for InferWorkerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InferWorkerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "InferWorkerService",
	HandlerType: (*InferWorkerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReceiveTasksFromScheduler",
			Handler:    _InferWorkerService_ReceiveTasksFromScheduler_Handler,
		},
		{
			MethodName: "SendKVCacheData",
			Handler:    _InferWorkerService_SendKVCacheData_Handler,
		},
		{
			MethodName: "RecvKVCacheData",
			Handler:    _InferWorkerService_RecvKVCacheData_Handler,
		},
		{
			MethodName: "ShutDown",
			Handler:    _InferWorkerService_ShutDown_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "TaskInfo.proto",
}

const (
	CacheCoordinatorService_ReceiveTasksFromInferWorker_FullMethodName = "/CacheCoordinatorService/ReceiveTasksFromInferWorker"
	CacheCoordinatorService_PollBatchFromInferWorker_FullMethodName    = "/CacheCoordinatorService/PollBatchFromInferWorker"
	CacheCoordinatorService_StartProcessRequest_FullMethodName         = "/CacheCoordinatorService/StartProcessRequest"
	CacheCoordinatorService_ShutDown_FullMethodName                    = "/CacheCoordinatorService/ShutDown"
)

// CacheCoordinatorServiceClient is the client API for CacheCoordinatorService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// CacheCoordinator 服务
type CacheCoordinatorServiceClient interface {
	ReceiveTasksFromInferWorker(ctx context.Context, in *TaskInfoList, opts ...grpc.CallOption) (*Empty, error)
	PollBatchFromInferWorker(ctx context.Context, in *TaskInfoList, opts ...grpc.CallOption) (*ComfirmationMessage, error)
	StartProcessRequest(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*Empty, error)
	ShutDown(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
}

type cacheCoordinatorServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCacheCoordinatorServiceClient(cc grpc.ClientConnInterface) CacheCoordinatorServiceClient {
	return &cacheCoordinatorServiceClient{cc}
}

func (c *cacheCoordinatorServiceClient) ReceiveTasksFromInferWorker(ctx context.Context, in *TaskInfoList, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, CacheCoordinatorService_ReceiveTasksFromInferWorker_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cacheCoordinatorServiceClient) PollBatchFromInferWorker(ctx context.Context, in *TaskInfoList, opts ...grpc.CallOption) (*ComfirmationMessage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ComfirmationMessage)
	err := c.cc.Invoke(ctx, CacheCoordinatorService_PollBatchFromInferWorker_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cacheCoordinatorServiceClient) StartProcessRequest(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, CacheCoordinatorService_StartProcessRequest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cacheCoordinatorServiceClient) ShutDown(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, CacheCoordinatorService_ShutDown_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CacheCoordinatorServiceServer is the server API for CacheCoordinatorService service.
// All implementations must embed UnimplementedCacheCoordinatorServiceServer
// for forward compatibility.
//
// CacheCoordinator 服务
type CacheCoordinatorServiceServer interface {
	ReceiveTasksFromInferWorker(context.Context, *TaskInfoList) (*Empty, error)
	PollBatchFromInferWorker(context.Context, *TaskInfoList) (*ComfirmationMessage, error)
	StartProcessRequest(context.Context, *StartRequest) (*Empty, error)
	ShutDown(context.Context, *Empty) (*Empty, error)
	mustEmbedUnimplementedCacheCoordinatorServiceServer()
}

// UnimplementedCacheCoordinatorServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCacheCoordinatorServiceServer struct{}

func (UnimplementedCacheCoordinatorServiceServer) ReceiveTasksFromInferWorker(context.Context, *TaskInfoList) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReceiveTasksFromInferWorker not implemented")
}
func (UnimplementedCacheCoordinatorServiceServer) PollBatchFromInferWorker(context.Context, *TaskInfoList) (*ComfirmationMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PollBatchFromInferWorker not implemented")
}
func (UnimplementedCacheCoordinatorServiceServer) StartProcessRequest(context.Context, *StartRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartProcessRequest not implemented")
}
func (UnimplementedCacheCoordinatorServiceServer) ShutDown(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShutDown not implemented")
}
func (UnimplementedCacheCoordinatorServiceServer) mustEmbedUnimplementedCacheCoordinatorServiceServer() {
}
func (UnimplementedCacheCoordinatorServiceServer) testEmbeddedByValue() {}

// UnsafeCacheCoordinatorServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CacheCoordinatorServiceServer will
// result in compilation errors.
type UnsafeCacheCoordinatorServiceServer interface {
	mustEmbedUnimplementedCacheCoordinatorServiceServer()
}

func RegisterCacheCoordinatorServiceServer(s grpc.ServiceRegistrar, srv CacheCoordinatorServiceServer) {
	// If the following call pancis, it indicates UnimplementedCacheCoordinatorServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CacheCoordinatorService_ServiceDesc, srv)
}

func _CacheCoordinatorService_ReceiveTasksFromInferWorker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskInfoList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CacheCoordinatorServiceServer).ReceiveTasksFromInferWorker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CacheCoordinatorService_ReceiveTasksFromInferWorker_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CacheCoordinatorServiceServer).ReceiveTasksFromInferWorker(ctx, req.(*TaskInfoList))
	}
	return interceptor(ctx, in, info, handler)
}

func _CacheCoordinatorService_PollBatchFromInferWorker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskInfoList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CacheCoordinatorServiceServer).PollBatchFromInferWorker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CacheCoordinatorService_PollBatchFromInferWorker_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CacheCoordinatorServiceServer).PollBatchFromInferWorker(ctx, req.(*TaskInfoList))
	}
	return interceptor(ctx, in, info, handler)
}

func _CacheCoordinatorService_StartProcessRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CacheCoordinatorServiceServer).StartProcessRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CacheCoordinatorService_StartProcessRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CacheCoordinatorServiceServer).StartProcessRequest(ctx, req.(*StartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CacheCoordinatorService_ShutDown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CacheCoordinatorServiceServer).ShutDown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CacheCoordinatorService_ShutDown_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CacheCoordinatorServiceServer).ShutDown(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// CacheCoordinatorService_ServiceDesc is the grpc.ServiceDesc for CacheCoordinatorService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CacheCoordinatorService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "CacheCoordinatorService",
	HandlerType: (*CacheCoordinatorServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReceiveTasksFromInferWorker",
			Handler:    _CacheCoordinatorService_ReceiveTasksFromInferWorker_Handler,
		},
		{
			MethodName: "PollBatchFromInferWorker",
			Handler:    _CacheCoordinatorService_PollBatchFromInferWorker_Handler,
		},
		{
			MethodName: "StartProcessRequest",
			Handler:    _CacheCoordinatorService_StartProcessRequest_Handler,
		},
		{
			MethodName: "ShutDown",
			Handler:    _CacheCoordinatorService_ShutDown_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "TaskInfo.proto",
}

const (
	KVCacheService_ReceiveTasksFromCoordinator_FullMethodName = "/KVCacheService/ReceiveTasksFromCoordinator"
	KVCacheService_ShutDown_FullMethodName                    = "/KVCacheService/ShutDown"
)

// KVCacheServiceClient is the client API for KVCacheService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// KVCache 服务
type KVCacheServiceClient interface {
	ReceiveTasksFromCoordinator(ctx context.Context, in *TaskInfoList, opts ...grpc.CallOption) (*ComfirmationMessage, error)
	ShutDown(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
}

type kVCacheServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewKVCacheServiceClient(cc grpc.ClientConnInterface) KVCacheServiceClient {
	return &kVCacheServiceClient{cc}
}

func (c *kVCacheServiceClient) ReceiveTasksFromCoordinator(ctx context.Context, in *TaskInfoList, opts ...grpc.CallOption) (*ComfirmationMessage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ComfirmationMessage)
	err := c.cc.Invoke(ctx, KVCacheService_ReceiveTasksFromCoordinator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVCacheServiceClient) ShutDown(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, KVCacheService_ShutDown_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KVCacheServiceServer is the server API for KVCacheService service.
// All implementations must embed UnimplementedKVCacheServiceServer
// for forward compatibility.
//
// KVCache 服务
type KVCacheServiceServer interface {
	ReceiveTasksFromCoordinator(context.Context, *TaskInfoList) (*ComfirmationMessage, error)
	ShutDown(context.Context, *Empty) (*Empty, error)
	mustEmbedUnimplementedKVCacheServiceServer()
}

// UnimplementedKVCacheServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedKVCacheServiceServer struct{}

func (UnimplementedKVCacheServiceServer) ReceiveTasksFromCoordinator(context.Context, *TaskInfoList) (*ComfirmationMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReceiveTasksFromCoordinator not implemented")
}
func (UnimplementedKVCacheServiceServer) ShutDown(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShutDown not implemented")
}
func (UnimplementedKVCacheServiceServer) mustEmbedUnimplementedKVCacheServiceServer() {}
func (UnimplementedKVCacheServiceServer) testEmbeddedByValue()                        {}

// UnsafeKVCacheServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KVCacheServiceServer will
// result in compilation errors.
type UnsafeKVCacheServiceServer interface {
	mustEmbedUnimplementedKVCacheServiceServer()
}

func RegisterKVCacheServiceServer(s grpc.ServiceRegistrar, srv KVCacheServiceServer) {
	// If the following call pancis, it indicates UnimplementedKVCacheServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&KVCacheService_ServiceDesc, srv)
}

func _KVCacheService_ReceiveTasksFromCoordinator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskInfoList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVCacheServiceServer).ReceiveTasksFromCoordinator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KVCacheService_ReceiveTasksFromCoordinator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVCacheServiceServer).ReceiveTasksFromCoordinator(ctx, req.(*TaskInfoList))
	}
	return interceptor(ctx, in, info, handler)
}

func _KVCacheService_ShutDown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVCacheServiceServer).ShutDown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KVCacheService_ShutDown_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVCacheServiceServer).ShutDown(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// KVCacheService_ServiceDesc is the grpc.ServiceDesc for KVCacheService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var KVCacheService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "KVCacheService",
	HandlerType: (*KVCacheServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReceiveTasksFromCoordinator",
			Handler:    _KVCacheService_ReceiveTasksFromCoordinator_Handler,
		},
		{
			MethodName: "ShutDown",
			Handler:    _KVCacheService_ShutDown_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "TaskInfo.proto",
}
